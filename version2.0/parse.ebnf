(*
 <>  must choose
 []  can choose
 {}  can repeat 0 to infinite time(s)
 |   or
 ::= is defined as
*)
<var> = <token_var_reserve_word> ;
<func> = <token_func_reserve_word> ;
<and> = <token_and_operator> ;
<or> = <token_or_operator> ;
<number> = <token_number> ;
<string> = <token_string> ;
<nil> = <token_reserve_word_nil> ;
<id> = <token_identifier> ;
<dynamic_id> = <token_dynamic_id> ;

<vector> = '[' { <calculation> ',' } ']' ;
<hash> = '{' {(<id> | <string>) ':' <scalar> ','} '}' ;
<scalar> =
    <number>
|   <nil>
|   <string>
|   <id>
|   <hash>
|   <vector>
|   <func> <id>
|   <function>
|   '(' <calculation> ')'
|   <scalar> { ('[' {<calculation> ','} ']') | ('[' <calculation> ':' [<calculation>] ']') | ('.' <id>) | ('(' {<calculation> ','} ')') | ('(' {<id> ':' <calculation> ','} ')') }
;

<function> =
    <func> ['(' ')'] <statement>
|   <func> ['(' ')'] '{' {<statement> ';'} '}'
|   <func> '(' {<id> ','} {<id> '=' <calculation> ','} {<dynamic_id>} ')' <statement>
|   <func> '(' {<id> ','} {<id> '=' <calculation> ','} {<dynamic_id>} ')' '{' {<statement> ';'} '}'
;

<calculation> =
    <and_calc>
|   <or_calc>
|   <additive_calc>
|   <multive_calc>
|   [('-' | '!')] <scalar>
|   <calculation> '?' <calculation> ':' <calculation>
;
<and_calc> = <or_calc> {<and> <or_calc>} ;
<or_calc> = <additive_calc> {<or> <additive_calc>} ;
<additive_calc> = <multive_calc> {('+' | '-' | '~') <multive_calc>} ;
<multive_calc> = [('-' | '!')] <scalar> {('*' | '/') [('-' | '!')] <scalar>};

(* this definition is also used in for loop*)
<definition> =
    <var> <id> '=' <scalar>
|   <var> '(' {<id> ','} ')' '=' (<scalar> | '(' {<scalar> ','} ')')
|   '(' <var> {<id> ','} ')' '=' (<scalar> | '(' {<scalar> ','} ')')
;

<assignment> =
    <scalar> ('=' | '+=' | '-=' | '*=' | '/=' | '~=') <calculation>
|   '(' {<scalar> ','} ')' ('=' | '+=' | '-=' | '*=' | '/=' | '~=') (<calculation> | '(' {<calculation> ','} ')')
;
<loop_expr> =
    <for_loop>
|   <while_loop>
|   <forindex_loop>
|   <foreach_loop>
;
<for_loop> =
    <for> '(' [<statement>] ';' [<calculation>] ';' [<statement>] ')' <statement> [';']
|   <for> '(' [<statement>] ';' [<calculation>] ';' [<statement>] ')' '{' {<statement> ';'} '}'
;
<while_loop> =
    <while> '(' <calculation> ')' <statement> [';']
|   <while> '(' <calculation> ')' '{' {<statement> ';'} '}'
;
(* in forindex and foreach the scalar and definition cannot be lacked*)
<forindex_loop> =
    <forindex> '(' (<var> <id>)|(<id>) ';' <scalar> ')' <statement> [';']
|   <forindex> '(' (<var> <id>)|(<id>) ';' <scalar> ')' '{' {<statement> ';'} '}'
;
<foreach_loop> =
    <foreach> '(' (<var> <id>)|(<id>) ';' <scalar> ')' <statement> [';']
|   <foreach> '(' (<var> <id>)|(<id>) ';' <scalar> ')' '{' {<statement> ';'} '}'
;

<choose_expr> = <choose_expr_if> {<choose_expr_elsif>} [<choose_expr_else>]
;
<choose_expr_if> =
    <if> '(' <calculation> ')' <statement> [';']
|   <if> '(' <calculation> ')' '{' {<statement> ';'} '}'
;
<choose_expr_elsif> =
    <elsif> '(' <calculation> ')' <statement> [';']
|   <elsif> '(' <calculation> ')' '{' {<statement> ';'} '}'
|   <else> <if> '(' <calculation> ')' <statement> [';']
|   <else> <if> '(' <calculation> ')' '{' {<statement> ';'} '}'
;
<choose_expr_else> =
    <else> <statement> [';']
|   <else> '{' {<statement> ';'} '}'
;

<continue_expr> = <continue> ;
<break_expr> = <break> ;
<return_expr> = <return> [<scalar>] ;
<statement> =
    <definition>
|   <assignment>
|   <choose_expr>
|   <loop_expr>
|   <continue_expr>
|   <break_expr>
|   <return_expr>
;