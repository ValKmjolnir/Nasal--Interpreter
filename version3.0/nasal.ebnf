(*
 <>  must choose
 []  can choose
 {}  can repeat 0 to infinite time(s)
 |   or
 ::= is defined as
*)

nil   ::= nil;
id    ::= identifier;
number::= number;
string::= string;
vector::= 
    '[' {calculation ','} ']'
;
hash  ::=
    '{' {hashmember ','} '}'
;
hashmember::=
    id ':' calculation
;
function::= 
    func argument_list expressions
;
argument_list::=
    '(' [{id ','} ([id '...']|{id '=' scalar ','})] ')'
;
expr::=
    definition
    |multi_assignment
    |calculation
    |loop
    |conditional
    |return_expr
    |continue_expr
    |break_expr
;
expressions::=
    '{' {expr} '}'
;
calculation::=
    |scalar
    |trinocular
    |or_expr
    |calculation ('=' | '+=' | '-=' | '*=' | '/=' | '~=') calculation
;
trinocular::=
    calculation '?' calculation ':' calculation
;
or_expr::=
    and_expr or and_expr
;
and_expr::=
    cmp_expr and cmp_expr
;
cmp_expr::=
    additive_expr ('==' | '!=' | '>' | '<' | '>=' | '<=') additive_expr
;
additive_expr::=
    multive_expr ('+' | '-' | '~') multive_expr
;
multive_expr::=
    (unary|scalar) ('*' | '/') (unary|scalar)
;
unary::=
    ('-'|'!') scalar
;
scalar::=
    function_call
    |identifier_call
    |vector_call
    |hash_call
    |number
    |string
    |'(' calculation ')'
;
function_call::=
    function {call_scalar}
;
identifier_call::=
    id {call_scalar}
;
vector_call::=
    vector {call_scalar}
;
hash_call::=
    hash {call_scalar}
;
call_scalar::=
    '.' id
    |'[' {(calculation | subvec) ','} ']'
    |'(' {calculation ','} ')'
    |'(' {hashmember ','} ')'
;
subvec::=
    calculation ':' calculation
    |calculation ':'
    |':' calculation
;
definition::=
    var id '=' calculation
    |var '(' multi_id ')' '=' (calculation | multi_scalar)
    |'(' var multi_id ')' '=' (calculation | multi_scalar)
;
multi_id::=
    {id ','} <id>
;
multi_scalar::=
    '(' {calculation ','} <calculation> ')'
;
multi_assignment::=
    multi_scalar '=' multi_scalar
;
loop::=
    while_loop
    |for_loop
    |forei_loop
;
while_loop::=
    while '(' calculation ')' expressions
;
for_loop::=
    for '(' [definition] ';' [calculation] ';' [calculation] ')' expressions
;
forei_loop::=
    (forindex | foreach) '(' (definition | assignment) ';' calculation ')' expressions
;
conditional::=
    if '(' calculation ')' expressions
    {elsif '(' calculation ')' expressions}
    [else expressions]
;
continue_expr::=
    continue
;
break_expr::=
    break
;
return_expr::=
    return [calculation]
;